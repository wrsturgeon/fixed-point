#ifndef FIXED_POINT_HPP
#define FIXED_POINT_HPP

#include <bit>          // for std::bit_width
#include <cmath>        // for ldexp, ldexpf, std::ldexp, std::ldexpf
#include <concepts>     // for std::integral, std::same_as, std::unsigned_integral
#include <cstdint>      // for int16_t, int32_t, int64_t, int8_t, std::int16_t, std::int32_t, std::int64_t, std::int8_t, std::uint16_t, std::uint32_t, std::uint64_t, std::uint8_t, uint16_t, uint32_t, uint64_t, uint8_t
#include <cstdlib>      // for abs, size_t, std::size_t
#include <type_traits>  // for std::conditional_t

extern "C" {
#include <limits.h>     // for CHAR_BIT
}

#ifndef FP_NOSTR
#include <iomanip>      // for std::fixed
#include <iostream>     // for std::string, std::__1::operator<<, std::ostream
#include <sstream>      // for std::stringstream
#include <string>       // for std::allocator, std::operator+, std::char_traits, std::basic_string, std::to_string
#else // FP_NOSTR
#if FP_NOSTR != 1
#error "FP_NOSTR must be either not defined or defined to 1"
#endif // FP_NOSTR != 1
#endif // FP_NOSTR

#define FP_INLINE [[gnu::always_inline]] inline
#define FP_IMPURE [[nodiscard]] FP_INLINE
#define FP_PURE FP_IMPURE constexpr

namespace fp {

namespace util {

// cstdint types with templated bit width
template <std::size_t B> struct s_int_struct {};
template <std::size_t I> struct u_int_struct {};
// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)
#define MAKEINT(B) template <> struct s_int_struct<B##U> { using type = std::int##B##_t; }; template <> struct u_int_struct<B##U> { using type = std::uint##B##_t; };
MAKEINT(8)
MAKEINT(16)
MAKEINT(32)
MAKEINT(64)
#undef MAKEINT
template <typename S> concept valid_sign = std::same_as<S, signed> or std::same_as<S, unsigned>;
template <std::size_t B> using s_int = typename s_int_struct<B>::type;
template <std::size_t B> using u_int = typename u_int_struct<B>::type;
template <std::size_t B, valid_sign S> using int_b = std::conditional_t<std::is_signed_v<S>, s_int<B>, u_int<B>>;

// Bad implementation but constexpr. Use only at compile time.
FP_PURE std::size_t byte_pow2_ceil(std::unsigned_integral auto x) noexcept {
  static_assert(CHAR_BIT == 8U, "As of now, this fixed-point library requires an 8-bit system byte.");
  std::size_t c = CHAR_BIT;
  while (x > c) { c <<= 1U; }
  return c;
}

// Log of size_t, which is in turn log of memory space.
// 16b is the minimum purely because it's a pain in the ass that C/++ translate *int8_t as a char
inline constexpr std::size_t lg_size = byte_pow2_ceil(static_cast<std::size_t>(std::bit_width(sizeof(std::size_t) << 3)));
using lg_size_t = int_b<(16 > lg_size ? 16 : lg_size), unsigned>;
using lg_ssize_t = int_b<(16 > lg_size ? 16 : lg_size), signed>;

// Bit-shifting operators that sidestep undefined behavior with negative shifts
template <lg_ssize_t Amount, typename T>
FP_PURE std::decay_t<T> rshift(T&& v) noexcept { if constexpr (Amount == 0) { return std::forward<T>(v); } else { if constexpr (Amount < 0) { return static_cast<std::decay_t<T>>(std::forward<T>(v) << -Amount); } else { return static_cast<std::decay_t<T>>(std::forward<T>(v) >> Amount); } } }
template <lg_ssize_t Amount, typename T>
FP_PURE std::decay_t<T> lshift(T&& v) noexcept { if constexpr (Amount == 0) { return std::forward<T>(v); } else { if constexpr (Amount < 0) { return static_cast<std::decay_t<T>>(std::forward<T>(v) >> -Amount); } else { return static_cast<std::decay_t<T>>(std::forward<T>(v) << Amount); } } }

template <typename T> using signedness = std::conditional_t<std::is_signed_v<T>, signed, unsigned>;
template <typename T> using flip_signedness = std::conditional_t<std::is_signed_v<T>, unsigned, signed>;

FP_PURE std::uint8_t dec_capacity(std::uint8_t bin_capacity) noexcept {
  std::size_t const total = (static_cast<std::size_t>(1) << bin_capacity);
  std::uint8_t d = 0;
  std::size_t exp = 10;
  while (total > exp) { ++d; exp *= 10; }
  return d;
}

} // namespace util

// Forward declaration
template <util::lg_size_t B, util::lg_ssize_t I, util::valid_sign S>
struct t;

namespace util {
template <typename T> struct is_fixed_point_s { static constexpr bool value = false; };
template <util::lg_size_t B, util::lg_ssize_t I, valid_sign S> struct is_fixed_point_s<t<B, I, S>> { static constexpr bool value = true; };
} // namespace util
template <typename T> concept any = util::is_fixed_point_s<std::decay_t<T>>::value;

template <util::lg_size_t B, util::lg_ssize_t I, util::valid_sign S>
struct t {
  static constexpr auto b = B;
  static constexpr auto i = I;
  using s = S;
  using internal_t = util::int_b<util::byte_pow2_ceil(b), s>;
  internal_t internal; // NOLINT(misc-non-private-member-variables-in-classes)
  static constexpr int fractional_bits = b - i - std::is_signed_v<s>;
  static constexpr std::uint8_t total_decimal = util::dec_capacity(b);
  static constexpr std::uint8_t fract_decimal = util::dec_capacity(fractional_bits);
  // no constructor
  template <any T> FP_PURE t<B, I, S>& operator=(T&& z) noexcept;
  template <any T> FP_PURE t<B, I, S>& operator=(T const& z) noexcept;
  FP_IMPURE explicit operator float() const noexcept requires (static_cast<int>(i) == i) { return std::ldexpf(static_cast<float>(internal), static_cast<int>(-fractional_bits)); }
  FP_IMPURE explicit operator double() const noexcept requires (static_cast<int>(i) == i) { return std::ldexp(static_cast<double>(internal), static_cast<int>(-fractional_bits)); }
#ifndef FP_NOSTR
  FP_IMPURE explicit operator std::string() const noexcept { return (std::stringstream{} << std::fixed << std::setw(3 + total_decimal) << std::setprecision(fract_decimal) << (operator double())).str(); }
#endif // FP_NOSTR
};

template <util::lg_ssize_t I>
inline constexpr decltype(auto) from_int = t<
  std::bit_width(static_cast<std::size_t>((I < 0) ? -I : I)) + (I < 0),
  std::bit_width(static_cast<std::size_t>((I < 0) ? -I : I)),
  std::conditional_t<(I < 0), signed, unsigned>>{ .internal = I };

// Bit-shifting by a known amount (can be negative!). This DOES NOT immediately change anything about the underlying bits; instead, it moves the templated radix point.
template <util::lg_ssize_t Amount, any T>
FP_PURE static
t<std::decay_t<T>::b, std::decay_t<T>::i + Amount, typename std::decay_t<T>::s>
lshift(T&& x)
noexcept {
  // https://stackoverflow.com/questions/54709377/how-to-perfect-forward-a-member-variable
  return t<std::decay_t<T>::b, std::decay_t<T>::i + Amount, typename std::decay_t<T>::s>{ .internal=std::forward<T>(x).internal };
}

// Bit-shifting by a known amount (can be negative!). This DOES NOT immediately change anything about the underlying bits; instead, it moves the templated radix point.
template <util::lg_ssize_t Amount, any T>
FP_PURE static
t<std::decay_t<T>::b, std::decay_t<T>::i - Amount, typename std::decay_t<T>::s>
rshift(T&& x)
noexcept {
  return t<std::decay_t<T>::b, std::decay_t<T>::i - Amount, typename std::decay_t<T>::s>{ .internal=std::forward<T>(x).internal };
}

// Bit-shifting by an unknown amount. Immediately bit-shifts the underlying representation without changing template parameters.
template <any T>
FP_PURE static
std::decay_t<T>
lshift(T&& x, util::lg_size_t z)
noexcept {
  return std::decay_t<T>{ .internal=(std::forward<T>(x).internal << z) };
}

// Bit-shifting by an unknown amount. Immediately bit-shifts the underlying representation without changing template parameters.
template <any T>
FP_PURE static
std::decay_t<T>
rshift(T&& x, util::lg_size_t z)
noexcept {
  return std::decay_t<T>{ .internal=(std::forward<T>(x).internal >> z) };
}

// Reformat an argument to take the same value (save for precision & overflow) in a different underlying format.
template <util::lg_size_t B, util::lg_ssize_t I, util::valid_sign S, any T>
FP_PURE static
t<B, I, S>
reformat(T&& x)
noexcept {
  static constexpr auto shift_amt = t<B, I, S>::fractional_bits - std::decay_t<T>::fractional_bits;
  using pre_shift_t = util::int_b<util::byte_pow2_ceil(((shift_amt > 0) ? shift_amt : 0) + (sizeof(std::decay_t<T>) << 3)), std::conditional_t<std::is_signed_v<T>, signed, unsigned>>;
  return t<B, I, S>{
    .internal=static_cast<typename t<B, I, S>::internal_t>(
      util::lshift<shift_amt>(static_cast<pre_shift_t>(std::forward<T>(x).internal))
    )
  };
}

template <util::lg_size_t B, util::lg_ssize_t I, util::valid_sign S>
template <any T>
FP_PURE
t<B, I, S>&
t<B, I, S>::operator=(T&& z)
noexcept {
  internal = reformat<B, I, S>(std::move(z)).internal;
  return *this;
}

template <util::lg_size_t B, util::lg_ssize_t I, util::valid_sign S>
template <any T>
FP_PURE
t<B, I, S>&
t<B, I, S>::operator=(T const& z)
noexcept {
  internal = reformat<B, I, S>(z).internal;
  return *this;
}

// Reformat an argument to take the same value (save for precision & overflow) in a different underlying format.
template <any T_out, any T_in>
FP_PURE static
std::decay_t<T_out>
reformat(T_in&& x)
noexcept {
  return reformat<std::decay_t<T_out>::b, std::decay_t<T_out>::i, typename std::decay_t<T_out>::s>(std::forward<T_in>(x));
}

// Addition. Always returns the same type as the first argument, adjusting precision of the second to match.
template <any T1, any T2>
FP_PURE static
std::decay_t<T1>
operator+(T1&& x, T2&& z)
noexcept {
  return std::decay_t<T1>{
    .internal=static_cast<typename std::decay_t<T1>::internal_t>(
      std::forward<T1>(x).internal + reformat<T1>(std::forward<T2>(z)).internal
    )
  };
}

// Subtraction. Always returns the same type as the first argument, adjusting precision of the second to match.
template <any T1, any T2>
FP_PURE static
std::decay_t<T1>
operator-(T1&& x, T2&& z)
noexcept {
  return std::decay_t<T1>{ .internal=(std::forward<T1>(x).internal - reformat<T1>(std::forward<T2>(z)).internal) };
}

namespace util {
template <any T1, any T2> inline constexpr bool both_signed = std::is_signed_v<typename std::decay_t<T1>::s> and std::is_signed_v<typename std::decay_t<T2>::s>;
template <any T1, any T2> inline constexpr bool either_signed = std::is_signed_v<typename std::decay_t<T1>::s> or std::is_signed_v<typename std::decay_t<T2>::s>;
} // namespace util

#define MUL_RETURN_T t<std::decay_t<T1>::b + std::decay_t<T2>::b - util::both_signed<T1, T2>, std::decay_t<T1>::i + std::decay_t<T2>::i, std::conditional_t<util::either_signed<T1, T2>, signed, unsigned>>
// Multiplication. Returns neither T1 nor T2; instead, returns exactly enough to prevent overflow (usually the sum of the input bits).
template <any T1, any T2>
FP_PURE static
MUL_RETURN_T
operator*(T1&& x, T2&& z)
noexcept {
  return MUL_RETURN_T{
    .internal=static_cast<typename MUL_RETURN_T::internal_t>(
      std::forward<T1>(x).internal * std::forward<T2>(z).internal
    )
  };
}
#undef MUL_RETURN_T

// Increments ONLY ONE ULP, not by 1.0 each time.
template <any T>
FP_PURE static
T&
operator++(T& x)
noexcept {
  ++x.internal;
  return x;
}

// Euclidean transformation : [-1, 1) <-> [0, 1) in one bitwise XOR
template <any T>
requires (std::decay_t<T>::i == 0)
FP_PURE static
t<std::decay_t<T>::b, 0, util::flip_signedness<typename std::decay_t<T>::s>>
rescale(T&& x)
noexcept {
  return t<std::decay_t<T>::b, 0, util::flip_signedness<typename std::decay_t<T>::s>>{
    .internal=static_cast<util::int_b<std::decay_t<T>::b, util::flip_signedness<typename std::decay_t<T>::s>>>(
      std::forward<T>(x).internal ^ util::lshift<std::decay_t<T>::b - 1>(1U)
    )
  };
}

#ifndef FP_NOSTR // String and stream operators

template <any T>
std::ostream& operator<<(std::ostream& os, T&& v) {
  return os << (std::forward<T>(v).operator std::string());
}

template <any T>
std::string operator+(std::string&& s, T&& v) {
  return std::move(s) + (std::forward<T>(v).operator std::string());
}

template <any T>
std::string operator+(std::string const& s, T&& v) {
  return s + (std::forward<T>(v).operator std::string());
}

template <any T>
std::string operator+(T&& v, std::string&& s) {
  return (std::forward<T>(v).operator std::string()) + std::move(s);
}

template <any T>
std::string operator+(T&& v, std::string const& s) {
  return (std::forward<T>(v).operator std::string()) + s;
}

template <any T>
std::string operator+(char const* const s, T&& v) {
  return s + (std::forward<T>(v).operator std::string());
}

template <any T>
std::string operator+(T&& v, char const* const s) {
  return (std::forward<T>(v).operator std::string()) + s;
}

#endif // FP_NOSTR

} // namespace fp

#undef FP_PURE
#undef FP_IMPURE
#undef FP_INLINE

#endif // FIXED_POINT_HPP
